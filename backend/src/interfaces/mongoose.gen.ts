/* tslint:disable */
/* eslint-disable */

// ######################################## THIS FILE WAS GENERATED BY MONGOOSE-TSGEN ######################################## //

// NOTE: ANY CHANGES MADE WILL BE OVERWRITTEN ON SUBSEQUENT EXECUTIONS OF MONGOOSE-TSGEN.

import mongoose from 'mongoose';

/**
 * Lean version of ProductDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ProductDocument.toObject()`. To avoid conflicts with model names, use the type alias `ProductObject`.
 * ```
 * const productObject = product.toObject();
 * ```
 */
export type Product = {
	_id: string;
	name: string;
	avgRating?: number;
	createdAt?: Date;
	updatedAt?: Date;
};

/**
 * Lean version of ProductDocument (type alias of `Product`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Product } from "../models"
 * import { ProductObject } from "../interfaces/mongoose.gen.ts"
 *
 * const productObject: ProductObject = product.toObject();
 * ```
 */
export type ProductObject = Product;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ProductQuery = mongoose.Query<
	any,
	ProductDocument,
	ProductQueries
> &
	ProductQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `ProductSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ProductQueries = {};

export type ProductMethods = {};

export type ProductStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Product = mongoose.model<ProductDocument, ProductModel>("Product", ProductSchema);
 * ```
 */
export type ProductModel = mongoose.Model<ProductDocument, ProductQueries> &
	ProductStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Product schema instances:
 * ```
 * const ProductSchema: ProductSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ProductSchema = mongoose.Schema<
	ProductDocument,
	ProductModel,
	ProductMethods,
	ProductQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Product = mongoose.model<ProductDocument, ProductModel>("Product", ProductSchema);
 * ```
 */
export type ProductDocument = mongoose.Document<string, ProductQueries> &
	ProductMethods & {
		_id: string;
		name: string;
		avgRating?: number;
		barcode: string;
		createdAt?: Date;
		updatedAt?: Date;
	};

/**
 * Lean version of ReviewReactionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ReviewDocument.toObject()`.
 * ```
 * const reviewObject = review.toObject();
 * ```
 */
export type ReviewReaction = {
	icon: 'üëç' | '‚ù§Ô∏è' | '‚ú®';
	userId: User['_id'] | User;
	_id: mongoose.Types.ObjectId;
	createdAt?: Date;
	updatedAt?: Date;
};

/**
 * Lean version of ReviewDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ReviewDocument.toObject()`. To avoid conflicts with model names, use the type alias `ReviewObject`.
 * ```
 * const reviewObject = review.toObject();
 * ```
 */
export type Review = {
	productId: Product['_id'] | Product;
	productName: string;
	productBarcode: string;
	authorId: User['_id'] | User;
	rating: number;
	picture?: string;
	text: string;
	tags: string[];
	reactions: ReviewReaction[];
	_id: mongoose.Types.ObjectId;
	createdAt?: Date;
	updatedAt?: Date;
};

/**
 * Lean version of ReviewDocument (type alias of `Review`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Review } from "../models"
 * import { ReviewObject } from "../interfaces/mongoose.gen.ts"
 *
 * const reviewObject: ReviewObject = review.toObject();
 * ```
 */
export type ReviewObject = Review;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ReviewQuery = mongoose.Query<any, ReviewDocument, ReviewQueries> &
	ReviewQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `ReviewSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ReviewQueries = {};

export type ReviewMethods = {};

export type ReviewStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Review = mongoose.model<ReviewDocument, ReviewModel>("Review", ReviewSchema);
 * ```
 */
export type ReviewModel = mongoose.Model<ReviewDocument, ReviewQueries> &
	ReviewStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Review schema instances:
 * ```
 * const ReviewSchema: ReviewSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ReviewSchema = mongoose.Schema<
	ReviewDocument,
	ReviewModel,
	ReviewMethods,
	ReviewQueries
>;

/**
 * Mongoose Subdocument type
 *
 * Type of `ReviewDocument["reactions"]` element.
 */
export type ReviewReactionDocument = mongoose.Types.Subdocument & {
	icon: 'üëç' | '‚ù§Ô∏è' | '‚ú®';
	userId: UserDocument['_id'] | UserDocument;
	_id: mongoose.Types.ObjectId;
	createdAt?: Date;
	updatedAt?: Date;
};

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Review = mongoose.model<ReviewDocument, ReviewModel>("Review", ReviewSchema);
 * ```
 */
export type ReviewDocument = mongoose.Document<
	mongoose.Types.ObjectId,
	ReviewQueries
> &
	ReviewMethods & {
		productId: ProductDocument['_id'] | ProductDocument;
		productName: string;
		productBarcode: string;
		authorId: UserDocument['_id'] | UserDocument;
		rating: number;
		picture?: string;
		text: string;
		tags: mongoose.Types.Array<string>;
		reactions: mongoose.Types.DocumentArray<ReviewReactionDocument>;
		_id: mongoose.Types.ObjectId;
		createdAt?: Date;
		updatedAt?: Date;
	};

/**
 * Lean version of UserDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `UserDocument.toObject()`. To avoid conflicts with model names, use the type alias `UserObject`.
 * ```
 * const userObject = user.toObject();
 * ```
 */
export type User = {
	displayName: string;
	email: string;
	hash_password: string;
	picture?: string;
	_id: mongoose.Types.ObjectId;
	createdAt?: Date;
	updatedAt?: Date;
};

/**
 * Lean version of UserDocument (type alias of `User`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { User } from "../models"
 * import { UserObject } from "../interfaces/mongoose.gen.ts"
 *
 * const userObject: UserObject = user.toObject();
 * ```
 */
export type UserObject = User;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type UserQuery = mongoose.Query<any, UserDocument, UserQueries> &
	UserQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `UserSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type UserQueries = {};

export type UserMethods = {
	comparePassword: (this: UserDocument, ...args: any[]) => any;
};

export type UserStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const User = mongoose.model<UserDocument, UserModel>("User", UserSchema);
 * ```
 */
export type UserModel = mongoose.Model<UserDocument, UserQueries> & UserStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new User schema instances:
 * ```
 * const UserSchema: UserSchema = new mongoose.Schema({ ... })
 * ```
 */
export type UserSchema = mongoose.Schema<
	UserDocument,
	UserModel,
	UserMethods,
	UserQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const User = mongoose.model<UserDocument, UserModel>("User", UserSchema);
 * ```
 */
export type UserDocument = mongoose.Document<
	mongoose.Types.ObjectId,
	UserQueries
> &
	UserMethods & {
		displayName: string;
		email: string;
		hash_password: string;
		picture?: string;
		_id: mongoose.Types.ObjectId;
		createdAt?: Date;
		updatedAt?: Date;
	};

/**
 * Check if a property on a document is populated:
 * ```
 * import { IsPopulated } from "../interfaces/mongoose.gen.ts"
 *
 * if (IsPopulated<UserDocument["bestFriend"]>) { ... }
 * ```
 */
export function IsPopulated<T>(doc: T | mongoose.Types.ObjectId): doc is T {
	return doc instanceof mongoose.Document;
}

/**
 * Helper type used by `PopulatedDocument`. Returns the parent property of a string
 * representing a nested property (i.e. `friend.user` -> `friend`)
 */
type ParentProperty<T> = T extends `${infer P}.${string}` ? P : never;

/**
 * Helper type used by `PopulatedDocument`. Returns the child property of a string
 * representing a nested property (i.e. `friend.user` -> `user`).
 */
type ChildProperty<T> = T extends `${string}.${infer C}` ? C : never;

/**
 * Helper type used by `PopulatedDocument`. Removes the `ObjectId` from the general union type generated
 * for ref documents (i.e. `mongoose.Types.ObjectId | UserDocument` -> `UserDocument`)
 */
type PopulatedProperty<Root, T extends keyof Root> = Omit<Root, T> & {
	[ref in T]: Root[T] extends mongoose.Types.Array<infer U>
		? mongoose.Types.Array<Exclude<U, mongoose.Types.ObjectId>>
		: Exclude<Root[T], mongoose.Types.ObjectId>;
};

/**
 * Populate properties on a document type:
 * ```
 * import { PopulatedDocument } from "../interfaces/mongoose.gen.ts"
 *
 * function example(user: PopulatedDocument<UserDocument, "bestFriend">) {
 *   console.log(user.bestFriend._id) // typescript knows this is populated
 * }
 * ```
 */
export type PopulatedDocument<DocType, T> = T extends keyof DocType
	? PopulatedProperty<DocType, T>
	: ParentProperty<T> extends keyof DocType
	? Omit<DocType, ParentProperty<T>> & {
			[ref in ParentProperty<T>]: DocType[ParentProperty<T>] extends mongoose.Types.Array<
				infer U
			>
				? mongoose.Types.Array<
						ChildProperty<T> extends keyof U
							? PopulatedProperty<U, ChildProperty<T>>
							: PopulatedDocument<U, ChildProperty<T>>
				  >
				: ChildProperty<T> extends keyof DocType[ParentProperty<T>]
				? PopulatedProperty<DocType[ParentProperty<T>], ChildProperty<T>>
				: PopulatedDocument<DocType[ParentProperty<T>], ChildProperty<T>>;
	  }
	: DocType;

/**
 * Helper types used by the populate overloads
 */
type Unarray<T> = T extends Array<infer U> ? U : T;
type Modify<T, R> = Omit<T, keyof R> & R;

/**
 * Augment mongoose with Query.populate overloads
 */
declare module 'mongoose' {
	interface Query<ResultType, DocType, THelpers = {}> {
		populate<T extends string>(
			path: T,
			select?: string | any,
			model?: string | Model<any, THelpers>,
			match?: any
		): Query<
			ResultType extends Array<DocType>
				? Array<PopulatedDocument<Unarray<ResultType>, T>>
				: ResultType extends DocType
				? PopulatedDocument<Unarray<ResultType>, T>
				: ResultType,
			DocType,
			THelpers
		> &
			THelpers;

		populate<T extends string>(
			options: Modify<PopulateOptions, { path: T }> | Array<PopulateOptions>
		): Query<
			ResultType extends Array<DocType>
				? Array<PopulatedDocument<Unarray<ResultType>, T>>
				: ResultType extends DocType
				? PopulatedDocument<Unarray<ResultType>, T>
				: ResultType,
			DocType,
			THelpers
		> &
			THelpers;
	}
}
